{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6***","webpack:///webpack/bootstrap ae100f90e7d971b83ff6?df48***","webpack:///./lib-bb-challenge-ng/model.xml","webpack:///./lib-bb-challenge-ng/scripts/index.js","webpack:///external \"vendor-bb-angular\"?a114","webpack:///external \"lib-bb-intent-ng\"","webpack:///./lib-bb-challenge-ng/scripts/interceptors.js","webpack:///./lib-bb-challenge-ng/scripts/utils.js","webpack:///./lib-bb-challenge-ng/scripts/constants.js","webpack:///./lib-bb-challenge-ng/scripts/configuration.js"],"names":["moduleKey","bbChallengeKey","module","provider","challengeToIntent","setChallengeToIntent","challengeToIntentObject","constructor","Object","assign","$get","bbIntent","$injector","Promise","name","intents","noop","resolveIntent","keys","forEach","key","intentKey","create","intentResponse","interceptor","responseError","response","header","headers","HEADER_ATTRIBUTE","config","$http","get","isChallengeResponse","status","reject","getChallengeTypeKey","newResolve","parseChallengeHeader","then","headerResult","processChallengeResponse","customHeaders","challengeType","split","isChallengeStatus","responseStatus","STATUS_CODE","Boolean","entries","map","value","join","DELIMITER","KEY_VALUE_SEPARATOR","reduce","acc","item","trim","JSON","parse","challengeResponse","challengeRequest","sms"],"mappings":"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","file":"lib-bb-challenge-ng/scripts/lib-bb-challenge-ng.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vendor-bb-angular\"), require(\"lib-bb-intent-ng\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"lib-bb-challenge-ng\", [\"vendor-bb-angular\", \"lib-bb-intent-ng\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lib-bb-challenge-ng\"] = factory(require(\"vendor-bb-angular\"), require(\"lib-bb-intent-ng\"));\n\telse\n\t\troot[\"lib-bb-challenge-ng\"] = factory(root[\"vendor-bb-angular\"], root[\"lib-bb-intent-ng\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ae100f90e7d971b83ff6","module.exports = require(\"./scripts/index.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib-bb-challenge-ng/model.xml\n// module id = 0\n// module chunks = 3","/**\n * @module lib-bb-challenge\n * @description Library to provide a support for the MFA to a widget.\n * When the library is included in a data-module  it intercepts HTTP 401\n * unauthorized/challenge responses from the server and calls the specified widget.\n *\n *\n * Please note, the library has following limitations:\n * - It can only work with one request at a time.\n * - It can only work if the intent is handled on the same page.\n * On web, that could be a modal. On mobile if it navigates away,\n * the original page would need to be \"retained\".\n *\n * The library relies on a challenge definition in a RAML specification. E.g. if it looks like this:\n *\n * ```\n *  challengable:\n *    headers:\n *      X-MFA:\n *        description: Challenge payload response\n *        required: false\n *        example: sms challenge=\"123456789\"\n *    responses:\n *      401:\n *        description: Unauthorized\n *        headers:\n *          WWW-Authenticate:\n *            description: Comma separated challenges\n *            required: false\n *            example: sms challenge=\"\", pki challenge=\"Z8nlwZe0daUNWCWIbfJe3iIgauh\"\n *        body:\n *          application/json:\n *            type: Unauthorized-Error\n * ```\n *\n * The flow will be:\n * * Initial request sent by a widget (e.g. new payment, which should have step up authentication);\n * * Service responds with `401` status and `WWW-Authenticate` header,\n * it will require a specific challenge type, e.g. `\"sms challenge\"`;\n * * Library triggers intent and passes the information to the mediator-widget.\n * I.e. intent payload will be `{'sms challenge': ''}`\n * * Then the mediator-widget will send the intent response: `{'sms challenge':'123456789'}`\n * * This will be result in a second request to the backend,\n * which will contain a header: `X-MFA: sms challenge=\"123456789\"`\n *\n * @example\n * The best place to inject library is the data module of capability that requires MFA\n * // index.js\n *\n * // Import lib-bb-challenge-ng\n * import bbChallengeModuleKey, {\n *   bbChallengeKey,\n * } from 'lib-bb-challenge-ng';\n *\n * // Inject it in your data module\n * export default angular\n *   .module(moduleKey, [\n *     cXPAuthenticationDataModuleKey,\n *     ...\n *     bbChallengeModuleKey,\n *   ])\n *   .provider(cXPAuthenticationDataKey, [() => {\n *     ...\n *     return {\n *       $get: [\n *         bbChallengeKey,\n *         // Into\n *         cXPAuthenticationData,\n *       ],\n *     }\n *   }])\n *   .config(['$httpProvider', ($httpProvider) => {\n *     // Configure $http service to use challenge interceptor\n *     $httpProvider.interceptors.push(bbChallengeKey);\n *   }])\n */\nimport angular from 'vendor-bb-angular';\nimport bbIntentModuleKey, { bbIntentKey } from 'lib-bb-intent-ng';\nimport interceptor from './interceptors';\nimport challengeToIntentConf from './configuration';\n\nconst moduleKey = 'lib-bb-challenge-ng';\n\n/**\n * The dependency injection key for the BbChallenge Service\n * @name bbChallengeKey\n * @type {string}\n */\nexport const bbChallengeKey = `${moduleKey}:challenge`;\n\n/**\n * @name default\n * @type {string}\n * @description Angular module name\n */\nexport default angular\n  .module(moduleKey, [bbIntentModuleKey])\n  /**\n   * @name BbChallengeProvider\n   * @ngkey lib-bb-challenge-ng:challengeProvider\n   * @type {object}\n   * @description A provider that allows configuration\n   * of the challenge type/intent key map.\n   * @example\n   * // General usage:\n   * angular.module(...)\n   *   .config([\n   *     `${bbChallengeKey}Provider`,\n   *     (challengeProvider) => {\n   *       challengeProvider.setChallengeToIntent(...);\n   *     }\n   *   ]);\n   *\n   * export default [\n   *   ['lib-bb-challenge-ng:challengeProvider', (challenges) => {\n   *       challenges.setChallengeToIntent({sms: 'some.intent'});\n   *   }],\n   * ];\n   */\n  .provider(bbChallengeKey, () => {\n    let challengeToIntent = challengeToIntentConf;\n\n    return {\n      /**\n       * @name BbChallengeProvider#setChallengeToIntent\n       * @type {function}\n       * @description The setter for setChallengeToIntent mapping\n       * which can be customized in config-bb-providers\n       * @param {object.<string>} routes A map of challenge types to intent keys\n       */\n      setChallengeToIntent: (challengeToIntentObject) => {\n        if (challengeToIntentObject && challengeToIntentObject.constructor === Object) {\n          challengeToIntent = Object.assign(challengeToIntentConf, challengeToIntentObject);\n        }\n      },\n\n      /**\n       * @name BbChallengeProvider#$get\n       * @type {function}\n       * @description $get method of the provider for instantiation\n       * @returns {Interceptor} Challenge service\n       */\n      $get: [\n        bbIntentKey,\n        '$injector',\n        '$q',\n        (bbIntent, $injector, Promise) =>\n          interceptor(bbIntent, $injector, Promise, challengeToIntent),\n      ],\n    };\n  })\n\n  .name;\n\n\n\n// WEBPACK FOOTER //\n// ./lib-bb-challenge-ng/scripts/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vendor-bb-angular\"\n// module id = 5\n// module chunks = 3 5 6 7 8 9 10 12 16 19 22 24 26 27","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lib-bb-intent-ng\"\n// module id = 6\n// module chunks = 3 8","import utils from './utils';\nimport { challengeResponse, challengeRequest } from './constants';\n\nexport default (bbIntent, $injector, Promise, challengeToIntent) => {\n  const intents = {};\n  const noop = () => {};\n\n  let resolveIntent = noop;\n  // create all the intents upfront\n  Object.keys(challengeToIntent).forEach((key) => {\n    const intentKey = challengeToIntent[key];\n\n    intents[intentKey] = bbIntent.create(intentKey, (intentResponse) => {\n      resolveIntent(intentResponse);\n    });\n  });\n\n  /**\n   * @name interceptor\n   * @description The object to handle interception of challengable responses.\n   * for more details\n   * @type {Interceptor}\n   */\n  const interceptor = {\n    /**\n     * @name interceptor#responseError\n     * @type {function}\n     * @description This function determines if the request is \"challengable\" or not.\n     * It also implements handling of a requests with challenge.\n     * @param {object} response  original http response object\n     * @returns {Promise} Returns the response object as a promise.\n     */\n    responseError: (response) => {\n      const header = response.headers(challengeResponse.HEADER_ATTRIBUTE)\n        || response.config.headers[challengeResponse.HEADER_ATTRIBUTE];\n      const $http = $injector.get('$http');\n\n      if (!utils.isChallengeResponse(response.status, header)) {\n        return Promise.reject(response);\n      }\n\n      return new Promise(newResolve => {\n        const intentKey = challengeToIntent[utils.getChallengeTypeKey(header)];\n        resolveIntent = newResolve;\n        intents[intentKey](utils.parseChallengeHeader(header));\n      })\n      .then(intentResponse => {\n        const headerResult = utils.processChallengeResponse(intentResponse);\n        const customHeaders = { [challengeRequest.HEADER_ATTRIBUTE]: headerResult };\n        // eslint-disable-next-line no-param-reassign\n        delete response.config.headers[challengeResponse.HEADER_ATTRIBUTE];\n\n        Object.assign(response.config.headers, customHeaders);\n        resolveIntent = noop;\n      })\n      .then(() => $http(response.config));\n    },\n  };\n\n  return interceptor;\n};\n\n/**\n * @typedef {object} Interceptor\n * @description The object to handle interception. Please\n * see [angularjs interceptiors docs](https://docs.angularjs.org/api/ng/service/$http#interceptors)\n * for more details on other types of interceptors.\n * @property {ResponseError} responseError\n */\n\n/**\n * @typedef {function} ResponseError\n * @description The interceptor gets called when a previous\n * interceptor threw an error or resolved with a rejection.\n * @param {object} _response  interceptors get called with http response object\n * @returns {Promise} Returns the response object as a promise\n */\n\n\n\n// WEBPACK FOOTER //\n// ./lib-bb-challenge-ng/scripts/interceptors.js","import { challengeResponse } from './constants';\n\n/**\n * @name getChallengeTypeKey\n * @type {function}\n * @description Helper to get the challenge type key\n * from the challengeType string\n * @inner\n * @param {string} challengeType string with the challenge type\n * @returns {string} challengeTypeKey\n */\nconst getChallengeTypeKey = challengeType => challengeType.split(' ')[0];\n\n/**\n * @name isChallengeStatus\n * @type {function}\n * @inner\n * @description A helper to determine if\n * the response status is the challenge one\n * @param {number} responseStatus the response status code\n * @returns {boolean} true if the response has the challenge status\n */\nconst isChallengeStatus = responseStatus =>\n  responseStatus === challengeResponse.STATUS_CODE;\n\n/**\n * @name isChallengeResponse\n * @type {function}\n * @inner\n * @description A helper to determine if the response\n * is challengable\n * @param {number} status response status to be verified\n * @param {string} header response header\n * @returns {Boolean} Returns true if the passed status is challenge response status\n * and the header is defined\n */\nconst isChallengeResponse = (status, header) =>\n  Boolean(isChallengeStatus(status) && header);\n\n/**\n * @name processChallengeResponse\n * @type {function}\n * @inner\n * @description A helper to stringify the challenge response object\n * @param {object} response the response object\n * @returns {string} stringified response object\n */\nconst processChallengeResponse = response => Object.entries(response)\n  .map(([key, value]) => {\n    if (typeof value === 'string') {\n      return `${key}=\"${value}\"`;\n    }\n    return `${key}=${value}`;\n  })\n  .join(', ');\n\n/**\n * @name parseChallengeHeader\n * @type {function}\n * @inner\n * @description Handler to parse header\n * @param {string} header the header string\n * @returns {object} JSON object with all the headers being represented as K:V pairs\n */\nconst parseChallengeHeader = header => {\n  const DELIMITER = ',';\n  const KEY_VALUE_SEPARATOR = '=';\n\n  return header.split(DELIMITER).reduce((acc, item) => {\n    const [key, value] = item.split(KEY_VALUE_SEPARATOR);\n    return Object.assign(acc, {\n      [key.trim()]: JSON.parse(value),\n    });\n  }, {});\n};\n\nexport default {\n  getChallengeTypeKey,\n  parseChallengeHeader,\n  isChallengeResponse,\n  processChallengeResponse,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib-bb-challenge-ng/scripts/utils.js","/**\n * @name challengeResponse\n * @type {object}\n *\n * @inner\n *\n * Default challenge response constant\n * It defines http response status code\n * and header attribute\n */\nexport const challengeResponse = {\n  STATUS_CODE: 401,\n  HEADER_ATTRIBUTE: 'WWW-Authenticate',\n};\n\n/**\n * @name challengeRequest\n * @type {object}\n *\n * @inner\n *\n * Default challenge request constant\n * It defines http request header attribute\n * for the MFA challenge\n */\nexport const challengeRequest = {\n  HEADER_ATTRIBUTE: 'X-MFA',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib-bb-challenge-ng/scripts/constants.js","/**\n * @name challengeToIntentConf\n * @type {object}\n * @description Challenge type to intent key map\n * It can be customized in config-bb-providers\n * @example\n * export default [\n *   ['lib-bb-challenge-ng:challengeProvider', (challenges) => {\n *       challenges.setChallengeToIntent({sms: 'some.intent'});\n *   }],\n * ];\n */\nexport default {\n  sms: 'sms.auth.step',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib-bb-challenge-ng/scripts/configuration.js"],"sourceRoot":""}